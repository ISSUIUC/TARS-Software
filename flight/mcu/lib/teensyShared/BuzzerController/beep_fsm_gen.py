"""
See the from_json method for a description of the JSON format this script expects.

To use, simply invoke this script with the path of the buzzes json file you want to input as a command line argument
"""

from __future__ import annotations

import clipboard

import json
import argparse
from dataclasses import dataclass
from pathlib import Path


@dataclass
class Item:
    """
    Stores the data for each individual beep or silence in a sequence.
    """
    sequence: Sequence
    index: int
    pitch: int | None
    length: int
    next_item: Item | None

    @property
    def enum_entry(self) -> str:
        return f"{self.sequence.name}_STATE_{self.index}"

    @property
    def table_entry(self) -> str:
        if self.pitch is None:
            pitch = "0"
        else:
            pitch = str(self.pitch)

        if self.next_item is None:
            next_item = "INITIAL"
        else:
            next_item = self.next_item.enum_entry

        return f"{{ {pitch}, {self.length}, {next_item} }}"


class Sequence:
    """
    Stores a beep sequence.
    """
    def __init__(self, name: str):
        self.name: str = name

        self._items: list[Item] = []

    @classmethod
    def from_json(cls, json_structure) -> Sequence:
        """
        Constructs a Sequence from some preparsed json, which is expected to follow the following format:

        At the top level, the json must be a list of sequence-describing objects.
        A sequence-describing object must have these three properties:
            - The "name" property must be a string containing a valid C++ identifier, which is the name of this sequence.
            - The "loop" property must be a boolean. If true, the sequence will automatically loop, otherwise, it returns
              to the initial state
            - The "sequence" property must a list of item lists.
                - Each item list must have exactly two items in it:
                    - The first item can be either a number or a null. If it's null, this item is silent. Otherwise, it's
                        a beep with the pitch of that number. Specifically, the pitch corresponds to the frequency of the
                        note in Hertz.
                    - The second item is the duration of this item in seconds as a number.

        :param json_structure: Parsed JSON. Nulls should be None, Objects are dicts, lists are lists, numbers are floats
        :return: A sequence from the JSON
        """
        # TODO use JSON schema to validate the inputted json

        name = json_structure["name"]
        obj = cls(name)

        for pitch, length in json_structure["sequence"]:
            obj._add_item(pitch, int(length * 1000))

        if json_structure["loop"]:
            obj._create_loop()

        return obj

    def _add_item(self, pitch: int | None, length: int):
        item = Item(self, len(self._items), pitch, length, None)
        if self._items:
            self._items[-1].next_item = item
        self._items.append(item)

    def _create_loop(self):
        self._items[-1].next_item = self._items[0]

    def num_entries(self) -> int:
        return len(self._items)

    def generate_enum_entries(self) -> list[str]:
        return [item.enum_entry for item in self._items]

    def generate_table_entries(self) -> list[str]:
        return [f"/* {item.enum_entry} */ {item.table_entry}" for item in self._items]


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("file", type=Path)

    source_file: Path = parser.parse_args().file
    data: list = json.loads(source_file.read_text())

    sequence_infos: list[Sequence] = []

    for sequence_info in data:
        sequence_infos.append(Sequence.from_json(sequence_info))

    generated = ""
    generated += "enum BuzzerState {\n"
    generated += "    INITIAL,\n"
    generated += "\n".join("    " + entry + "," for info in sequence_infos for entry in info.generate_enum_entries())
    generated += "\n};\n\n"

    clipboard.copy(generated)

    input("Paste your clipboard between the comments AUTOGENERATED 1 and END AUTOGENERATED 1 in BuzzerControl.hpp, "
          "replacing what's already inside, then press ENTER to continue")

    generated = ""
    generated += f"unsigned int BuzzerStates[{sum(info.num_entries() for info in sequence_infos) + 1}][3] = {{\n"
    generated += "    /* INITIAL*/ {0, 0, INITIAL},\n"
    generated += "\n".join("    " + entry + "," for info in sequence_infos for entry in info.generate_table_entries())
    generated += "\n};"

    clipboard.copy(generated)

    input("Paste your clipboard between the comments AUTOGENERATED 2 and END AUTOGENERATED 2 in BuzzerControl.hpp, "
          "replacing what's already inside")


if __name__ == "__main__":
    main()
